# HTTP — ACME + redirect to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name exemple.com www.exemple.com;  # à adapter (real domain)

    # Let Certbot place challenges here
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;  # à adapter (path used by certbot on the host)
        try_files $uri =404;
    }

    return 301 https://$host$request_uri;
}

# HTTPS — canonical host (no www)
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name exemple.com;  # à adapter (canonical host)

    # TLS (Certbot-managed)
    ssl_certificate     /etc/letsencrypt/live/exemple.com/fullchain.pem;  # à adapter
    ssl_certificate_key /etc/letsencrypt/live/exemple.com/privkey.pem;    # à adapter
    include /etc/letsencrypt/options-ssl-nginx.conf;                      # à adapter if distro path differs
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;                        # à adapter if distro path differs

    # Security headers (keep in sync with Django)
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "DENY" always;         # change to SAMEORIGIN only if needed
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    client_max_body_size 20M;  # à adapter (upload size)

    # Proxy to backend app (Gunicorn/Uvicorn)
    location / {
        # If Nginx and app are on the same host: keep 127.0.0.1
        # If inside a Docker network: use the service name (e.g., http://web:8000)
        proxy_pass http://127.0.0.1:8000;  # à adapter

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;

        # WebSocket/keep-alive (requires `map $http_upgrade $connection_upgrade` in nginx.conf http{})
        proxy_http_version 1.1;
        proxy_set_header Upgrade           $http_upgrade;
        proxy_set_header Connection        $connection_upgrade;

        proxy_read_timeout 60s;
        proxy_send_timeout 60s;
        proxy_redirect off;
    }

    # Optional: serve static files directly (if bind-mount them on the host)
    # location /static/ {
    #     alias /srv/site/static/;  # à adapter
    #     expires 30d;
    #     add_header Cache-Control "public, max-age=2592000, immutable";
    # }

    # Optional: serve media files directly
    # location /media/ {
    #     alias /srv/site/media/;   # à adapter
    #     expires 1h;
    #     add_header Cache-Control "public, max-age=3600";
    # }
}

# HTTPS — redirect www → apex (canonicalization)
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name www.exemple.com;  # à adapter

    # Reuse same cert (SAN must include both hosts)
    ssl_certificate     /etc/letsencrypt/live/exemple.com/fullchain.pem;  # à adapter
    ssl_certificate_key /etc/letsencrypt/live/exemple.com/privkey.pem;    # à adapter
    include /etc/letsencrypt/options-ssl-nginx.conf;                      # à adapter
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;                        # à adapter

    return 301 https://exemple.com$request_uri;  # à adapter (canonical host)
}
